{
    "contents" : "#' @name compileDecisionModel\n#' @export\n#' \n#' @title Compile JAGS Models to Evaluate the Effect of Decisions in a Network\n#' @description Nodes at which a decision can be made, such as the decision to \n#'   test or not test; treat or not treat; or use open or robotic surgery may \n#'   impact the outcome for a subject.  These types of decisions may not be \n#'   truly random and understanding how these decisions may impact downstream\n#'   outcomes may be beneficial to making the decision.  Compiling the decision\n#'   network permits the network to be evaluated under the conditions of each \n#'   set of decisions separately.\n#'   \n#' @param network A HydeNet object with decision nodes defined.\n#' @param policyMatrix A data frame of policies to apply to decision nodes\n#'   for comparing networks under different conditions.  See \n#'   \\code{\\link{policyMatrix}}.\n#' @param ... Additional arguments to pass to \\code{jags.model}, excepting\n#'   the \\code{data} argument.  The \\code{data} argument is created by \n#'   \\code{compileDecisionModel}, and cannot be passed manually.\n#' @param data An optional list of data values to be observed in the nodes.  \n#'   It is passed to the \\code{data} argument of \\code{rjags::jags}. Any\n#'   values given in \\code{data} will override values provided in \n#'   \\code{policyMatrix} with a warning.\n#'   \n#' @details \\code{compileDecisionModel} only accepts nodes of type \\code{\"dbern\"}\n#'   (Bernoulli random variable taking either 0 or 1) or \\code{\"dcat\"} \n#'   (categorical variables) as decision nodes.  \n#'   When the node is type \\code{\"dcat\"}, the \n#'   decision options are extracted from the JAGS statement returned by \n#'   \\code{writeJagsModel}.\n#'   \n#'   The options for each decision nodes (if there are multiple nodes) are \n#'   combined via \\code{expand.grid} to make a table of all possible decisions.\n#'   Each row of this table is passed as a list to the \\code{data} argument \n#'   of \\code{jags.model} (via \\code{compileJagsModel}) and a list of JAGS\n#'   model objects is returned.  \\code{coda.samples} may be run on each of these\n#'   models.\n#'   \n#' @return Returns a list of \\code{compiledHydeNetwork} objects.\n#' \n#' @author Jarrod Dalton and Benjamin Nutter\n#' \n#' @seealso \\code{\\link{policyMatrix}} \\code{\\link{compileJagsModel}}\n#' \n#' @examples\n#' data(PE, package=\"HydeNet\")\n#' Net <- HydeNetwork(~ wells + \n#'                      pe | wells + \n#'                      d.dimer | pregnant*pe + \n#'                      angio | pe + \n#'                      treat | d.dimer*angio + \n#'                      death | pe*treat,\n#'                      data = PE) \n#'                      \n#' \n#'                  \n#' Net <- setDecisionNodes(Net, treat)\n#' plot(Net)\n#' \n#' decision1 <- compileDecisionModel(Net)\n#'\n#' #* An effectively equivalent call as the previous\n#' decision2 <- compileDecisionModel(Net, policyMatrix(Net))\n#' \n#' #* Using a customized policy matrix\n#' #* Note: this is a bit of nonsense--you can't decide if a test is negative\n#' #*       or positive, but we'll do this for illustration.\n#' custom_policy <- policyMatrix(Net, \n#'                               treat=\"No\", \n#'                               angio = c(\"Negative\", \"Positive\"))\n#' decision3 <- compileDecisionModel(Net, custom_policy) \n#' \ncompileDecisionModel <- function(network, policyMatrix = NULL, ..., data = NULL){\n  Check <- ArgumentCheck::newArgCheck()\n  \n  dots <- list(...)\n  \n#   if (\"data\" %in% names(dots))\n#     ArgumentCheck::addError(\n#       msg = \"'data' is not an accepted argument in 'compileDecisionModel'\",\n#       argcheck = Check)\n#  \n  options <- makePolicyMatrix(network, policyMatrix, data, Check)\n\n  return(options)\n\n  ArgumentCheck::finishArgCheck(Check)\n  \n  cpt_arrays <- makeCptArrays(network)\n  \n  jags.code <- compileJagsModel(network, ...)\n  \n  lapply(options,\n         runJagsDecisionModel,\n         jags.code,\n         cpt_arrays, \n         ...)\n  \n  \n}\n\n\n#*********** UTILITY FUNCTIONS\n\nmakePolicyMatrix <- function(network, policyMatrix, data, argcheck){\n  if (is.null(policyMatrix))\n  {\n    decisionNodes <- names(network$nodeDecision)[sapply(network$nodeDecision, any)]\n    \n    if (length(decisionNodes) == 0)\n      ArgumentCheck::addError(\n        msg = \"No decision nodes indicated in the network\",\n        argcheck = argcheck)\n    \n    if (length(decisionNodes) == 0) break; # The next argument check isn't meaningful\n    # when this condition is true.\n    \n    validDecision <- sapply(network$nodeType[decisionNodes], \n                            function(x) x %in% c(\"dbern\", \"dcat\", \"dbin\"))\n    \n    if (!all(validDecision))\n      ArgumentCheck::addError(\n        msg = paste0(\"Only nodes of type 'dcat', and 'dbin' may be decision nodes.\\n  \",\n                     paste0(names(validDecision)[!validDecision], collapse=\", \"),\n                     \" cannot be used as decision nodes.\"),\n        argcheck = argcheck)\n    \n    if (!all(validDecision)) break; # Avoids defining 'options' when there are invalid decision nodes\n    \n    options <- lapply(decisionNodes, decisionOptions, network)\n    names(options) <- decisionNodes\n    \n    options <- expand.grid(options, stringsAsFactors=FALSE) \n  }\n  else\n  {\n    if (!is.data.frame(policyMatrix))\n      ArgumentCheck::addError(\n        msg = \"'policyMatrix' must be a data frame\",\n        argcheck = argcheck)\n    if (!is.data.frame(policyMatrix)) break; # avoids defining 'options' when\n    # the condition is not satisfied\n    options <- policyMatrix\n  }\n  \n  #* This is the part that pushes values from `data` into the \n  #* policy matrix.\n  if (!is.null(data)){\n    conflicts <- names(data)[names(data) %in% names(options)]\n    if (length(conflicts) > 0){\n      ArgumentCheck::addWarning(\n        msg = paste0(\"The following variables in 'data' are overriding \",\n                     \"values in 'policyMatrix': \",\n                     paste0(conflicts, collapse = \", \")),\n        argcheck = argcheck)\n    }\n    \n    for (i in names(data)){\n      options[[i]] <- data[[i]]\n    }\n    #* Remove duplicated rows\n    options <- options[!duplicated(options), , drop = FALSE]\n  }\n  \n  ArgumentCheck::finishArgCheck(argcheck)\n  \n  options <- lapply(1:nrow(options), \n                    function(i){ \n                      l <- as.list(options[i, , drop=FALSE])\n                      nms <- names(l)\n                      if (is.character(unlist(l)))\n                        l <- as.list(as.character(l))\n                      else l <- as.list(as.numeric(l))\n                      names(l) <- nms\n                      l\n                    })\n  \n  return(options)\n}\n\n#**\n\n\n\nmakeCptArrays <- function(network){\n  cpt_arrays <- unlist(network$nodeFitter) == \"cpt\"\n  if(any(cpt_arrays)){\n    cpt_arrays <- names(cpt_arrays)[cpt_arrays]\n    cpt_arrays <- network$nodeModel[cpt_arrays]\n    nms <- names(cpt_arrays)\n    cpt_arrays <- \n      lapply(names(cpt_arrays),\n             function(ca){\n               if (\"cpt\" %in% class(cpt_arrays[[ca]])) return(cpt_arrays[[ca]])\n               else{\n                 args <- \n                   list(formula = network$nodeFormula[[ca]],\n                        data = if (!is.null(network$nodeData[[ca]])) network$nodeData[[ca]]\n                        else network$data)\n                 if (!is.null(network$nodeFitterArgs[[ca]]))\n                   args <- c(args, network$nodeFitterArgs[[ca]])\n                 return(do.call(\"cpt\", args))\n               }   \n             })\n    names(cpt_arrays) <- paste0(\"cpt.\", nms)\n  } else cpt_arrays = list()\n  return(cpt_arrays) \n}\n\n#****\n\nrunJagsDecisionModel <- function(o, j, cpt_arrays, ...){\n  con <- textConnection(paste0(j$jags$model(),\n                                 collapse=\"\\n\"))\n  cHN <- list(jags = rjags::jags.model(con,\n                                       data = c(o, cpt_arrays),\n                                       ...),\n              observed = o,\n              dag = j$dag,\n              factorRef = j$factorRef)\n  class(cHN) <- c(\"compiledHydeNetwork\")\n  close(con)\n  return(cHN)\n}  \n",
    "created" : 1444395401228.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "749712867",
    "id" : "6BC4973F",
    "lastKnownWriteTime" : 1444396983,
    "path" : "~/GitHub/HydeNet/R/compileDecisionModel.R",
    "project_path" : "R/compileDecisionModel.R",
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "type" : "r_source"
}