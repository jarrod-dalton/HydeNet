{
    "contents" : "#' @name HydeUtilities\n#' @importFrom dplyr group_by_\n#' @importFrom dplyr mutate\n#' @importFrom magrittr %>%\n#' @export %>%\n#' \n#' @title Hyde Network Utility Functions \n#' @description The functions described below are unexported functions that \n#'   are used internally by \\code{HydeNet} to prepare modify network objects\n#'   and prepare JAGS code.\n#'   \n#' @details \n#'   \\code{termName}: In most model objects, factors in the model are \n#'   represented as [variable][level].  This utility function pulls out the \n#'   [variable] component.  This is typically called from within \n#'   \\code{makeJagsReady}.\n#'   \n#'   \\code{decisionOptions}: When compiling multiple JAGS models to evaluate the \n#'   effect of decision nodes, the options for each decision node are extracted\n#'   by this utility.\n#'   \n#'   \\code{makeJagsReady}: Manages the presence of factors in interactions and\n#'   makes sure the proper numeric factor value is given to the JAGS code.  \n#'   This is called from within a \\code{writeJagsFormula} call.\n#'   \n#'   \\code{matchLevelNumber}: Assigns the correct numeric value of a level to \n#'   a factor variable in a model.  This is called from within \n#'   \\code{makeJagsRead}.\n#'   \n#'   \\code{matchVars}: Given a list of existing node names, the terms of a formula\n#'   are matched to the node names.  This allows functions to be used in \n#'   formula defintions.  Most commonly, \\code{factor(var)} would get reduced to\n#'   \\code{var}, which is a node name that JAGS will understand.  There is still\n#'   limited ability for translation here, and \\code{matchVars} assumes that the \n#'   longest match is the desired match. If you pass a function with two node names,\n#'   the longer of the two will be taken and JAGS will likely fail.\n#'   \n#'   \\code{nodeFromFunction}: This is a utility function necessary to make \n#'   \\code{modelToNode} work properly.  A node vector was needed to pass to \n#'   \\code{matchVars}, and this is the mechanism to generate that vector.\n#'   \n#'   \\code{polyToPow}: converts polynomials generated by the \\code{poly} function\n#'   to use the \\code{pow} function in JAGS.\n#'   \n#'   \\code{validateParameters}: Users may pass parameters to the JAGS code using the \n#'   \\code{setNode} function.  If a faulty parameter is given, such as \n#'   \\code{lambda = -10} for a poisson distribution (\\code{lambda} must be\n#'   positive in a Poisson distribution), the error returned by JAGS may not\n#'   clear enough to diagnose a problem that presented several steps earlier\n#'   in the code.  \\code{validateParamters} allows the user to receive instant\n#'   feedback on the appropriateness of the code.\n#'   \n#'   Logical expressions for comparisons are stored in the \\code{jagsDists}\n#'   data object (\\code{data(jagsDists, package='Hyde')}).  This is a utility\n#'   function used only within \\code{setNode} and is not visible to the user.\n#'   \n#' @author Jarrod Dalton and Benjamin Nutter\n\n#' @rdname HydeUtilities\n#' @importFrom stringr str_extract\n#'   \n#' @param term Usually the \\code{term} column from the output of \n#'   \\code{broom::tidy()}\n#' @param reg A regular expression, usually provided by \\code{factorRegex}\n\ntermName <- function(term, reg){\n  if (!is.null(reg)){\n    return(sapply(term, \n                  function(t, reg){\n                    t <- unlist(strsplit(t, \":\"))\n                    t <- ifelse(grepl(reg, t),\n                                stringr::str_extract(t, reg),\n                                t)\n                    t <- paste(t, collapse=\":\")\n                  },\n                  reg))\n  }\n  else return(term)   \n}\n\n#' @rdname HydeUtilities\n#' @importFrom stringr perl\n#' @importFrom stringr str_extract\n#' \n#' @param node Character string indicating a node in a network\n#' @param network A Hyde Network Object\n\ndecisionOptions <- function(node, network){\n  #* In some cases, nodeFitter isn't set for a node.  When nodeFitter is NULL,\n  #* we want to skip the \"cpt\" check and move on to other possibilities.\n  #* If it isn't NULL and \"cpt\" is the fitter, we return dist immediately\n  #* to avoid overwriting it in subsequent checks\n  if (!is.null(network$nodeFitter[[node]])){\n    if (network$nodeFitter[[node]] == \"cpt\"){\n      D <- {if (!is.null(network$nodeData[[node]])) network$nodeData[[node]][[node]] \n            else network$data[[node]]}\n      dist <- 1:length(unique(D))\n      return(dist)\n    }\n  }\n  #* This uses a regular expression to extract the level number from\n  #* the node JAGS model.  For instance\n  #* pi.var[1] <- .123; pi.var[2] <- .321; ...\n  #* the regular expression pulls out the numbers in between each set of [].\n  if (network$nodeType[[node]] == \"dcat\"){\n    dist <- writeJagsModel(network, node)[1]\n    dist <- unlist(strsplit(dist, \";\"))\n    dist <- as.numeric(stringr::str_extract(dist, stringr::regex(\"(?<=[\\\\[]).*(?=[\\\\]])\")))\n  }\n  else if (network$nodeType[[node]] == \"dbern\"){\n    dist <- 0:1\n  }\n  dist\n}\n\n#' @rdname HydeUtilities \n#' @param mdl Output from \\code{broom::tidy()}\n#' @param regex A regular expression, usually returned by \\code{factorRegex}\n#' @param nodes A vector of node names, usually passed from \\code{network$nodes}.\n\nmakeJagsReady <- function(mdl, regex, nodes){\n  term_name <- NULL # avoids global binding NOTE on check\n  \n  mdl$term_name <- termName(as.character(mdl$term), regex)\n  mdl$term_name <- matchVars(mdl$term_name, nodes)\n  mdl$level_name <- if (!is.null(regex)) gsub(regex, \"\", mdl$term) else mdl$term\n  mdl$factor <- if (!is.null(regex)) grepl(regex, mdl$term) else FALSE\n  \n  factorRef <- mdl[mdl$factor & !grepl(\":\", mdl$term_name), \n                   c(\"term_name\", \"level_name\"), \n                   drop=FALSE]\n  if (nrow(factorRef) > 0){\n    factorRef <- factorRef %>%\n      dplyr::group_by_('term_name') %>%\n      dplyr::mutate(level_value = 2:(length(term_name) + 1))\n  }\n#   factorRef <- plyr::ddply(factorRef,\n#                            \"term_name\",\n#                            transform,\n#                            level_value = 2:(length(term_name)+1))\n  \n  mdl <- merge(mdl, factorRef,\n               by=c(\"term_name\", \"level_name\"), all=TRUE)\n  \n  mdl$jagsVar <- if (nrow(factorRef) > 0)\n                   mapply(matchLevelNumber, mdl$term_name, mdl$level_value)\n                 else mdl$term_name\n  \n  #* Change 'poly' to 'pow'\n  mdl$jagsVar <- sapply(mdl$jagsVar, polyToPow)\n  \n  mdl\n}\n\n#' @rdname HydeUtilities\n#' @param t Usually the \\code{term_name} column generated within \n#'   \\code{makeJagsReady}\n#' @param lev usually the \\code{level_value} column generated within\n#'   \\code{makeJagsReady}\n\nmatchLevelNumber <- function(t, lev){\n  t <- unlist(strsplit(t, \":\"))\n  l <- unlist(strsplit(as.character(lev), \":\"))\n  for (i in 1:length(t)){\n    t[i] <- {if (is.na(l[i])) t[i]\n             else paste0(\"(\", t[i], \" == \", l[i], \")\")}\n  }\n  paste0(t, collapse=\"*\")\n}\n\n#' @rdname HydeUtilities\n#' @param terms A vector of term names, usually from a \\code{broom::tidy} object.\n#' @param vnames A vector of term names, usually from \\code{network$nodes}.\n\nmatchVars <- function(terms, vnames)\n{\n  Matches <- sapply(vnames, function(p) stringr::str_extract(terms, p))\n  Matches <- apply(as.matrix(Matches), 1, function(s) ifelse(is.na(s), \"\", s))\n  Matches <- apply(as.matrix(Matches), 2, function(s) s[which.max(nchar(s))])\n  Matches[which(grepl(\"Intercept\", terms))] <- \n    terms[which(grepl(\"Intercept\", terms))]\n  Matches\n}\n\n#' @rdname HydeUtilities\n#' @param node_fn A character string representing a function passed in a model formula\n\nnodeFromFunction <- function(node_fn)\n{\n  node <- stringr::str_extract(node_fn, \"(?<=[(]).+?(?=[)])\")\n  node <- gsub(\"([*]|[,]|[/]|\\\\^)[[:print:]]+\", \"\", node)\n  ifelse(is.na(node), node_fn, node)\n}\n\n#' @rdname HydeUtilities\n#' @param poly A single term for which the polynomial components should be \n#'   converted to the JAGS pow() function.\n\npolyToPow <- function(poly){\n  poly <- unlist(strsplit(poly, \"[*]\"))\n  poly <- gsub(\"poly[(]\", \"pow(\", poly)\n  poly <- ifelse(grepl(\"pow[(]\", poly),\n                 gsub(\"\\\\d{1,2}[)]\", \"\", poly),\n                 poly)\n  poly <- ifelse(grepl(\"pow[(]\", poly),\n                 paste0(poly, \")\"),\n                 poly)\n  poly <- paste0(poly, collapse=\"*\")\n  return(poly)\n}\n\n  \n#' @rdname HydeUtilities\n#' @param params The list of parameters given in the \\code{...} argument of \n#'   \\code{setNode}\n#' @param dist The JAGS distribution function name.  Appropriate names are\n#'   in the \\code{FnName} column of the \\code{jagsDists} data object.\n\nvalidateParameters <- function(params, dist){\n  expr <- jagsDists$paramLogic[jagsDists$FnName == dist]\n  valid <- sapply(expr, function(e) with(params, eval(parse(text=e))))  \n  valid[sapply(params, function(p) p %in% c(\"fromData\", \"fromFormula\"))] <- TRUE\n  return(valid)\n}\n\n#' @rdname HydeUtilities\n#' \nmakeFactorRef <- function(network)\n{\n  network_factors <- \n    names(network$factorLevels)[!vapply(network$factorLevels, is.null, logical(1))]\n  \n  if (length(network_factors) == 0) return(NULL)\n  \n  Ref <- lapply(network_factors,\n         function(f){\n           data.frame(value = 1:length(network$factorLevels[[f]]),\n                      label = network$factorLevels[[f]],\n                      stringsAsFactors = FALSE)\n         })\n  names(Ref) <- network_factors\n  \n  types <- unlist(network$nodeType[network_factors])\n  types <- types[types %in% \"dbern\"]\n  \n  Ref[names(types)] <- \n    lapply(Ref[names(types)], \n           function(f){\n             f$value <- f$value - 1\n             f\n           })\n  \n  Ref[unique(names(Ref))]\n  #* The code below was the old way of doing this\n  #* before we implemented the `factorLevels` element.\n  #* I'm just hesitant to give it up before the \n  #* new system is well tested.\n#   dataList <- c(list(network$data), network$nodeData)\n#   names(dataList) <- NULL\n#   Ref <- do.call(\"c\", lapply(dataList, dataframeFactors))\n#   \n#   types <- unlist(network$nodeType[names(Ref)])\n#   types <- types[types %in% \"dbern\"]\n#   \n#   Ref[names(types)] <- \n#     lapply(Ref[names(types)], \n#            function(f){\n#              f$value <- f$value - 1\n#              f\n#            })\n#   Ref[unique(names(Ref))]\n}\n\n#' @rdname HydeUtilities\n#' @param dataframe A data frame.  The data frame will be searched for factors and\n#'   a reference table (another data frame) is returned.\n#'   \ndataframeFactors <- function(dataframe)\n{\n  if (is.null(dataframe)) return(NULL)\n  factor_vars <- names(dataframe)[sapply(dataframe, class) == \"factor\"]\n  reference_list <- \n    lapply(factor_vars,\n           function(f) data.frame(value = sort(unique(as.numeric(dataframe[[f]]))),\n                                  label = levels(dataframe[[f]]),\n                                  stringsAsFactors=FALSE))\n  names(reference_list) <- factor_vars\n  reference_list\n}",
    "created" : 1444396613889.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "699894500",
    "id" : "60CD9B16",
    "lastKnownWriteTime" : 1444394209,
    "path" : "~/GitHub/HydeNet/R/HydeUtilities.R",
    "project_path" : "R/HydeUtilities.R",
    "properties" : {
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "type" : "r_source"
}