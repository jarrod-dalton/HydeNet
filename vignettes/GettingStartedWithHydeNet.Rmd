<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{An overview of global options and recommendations}
-->
---
title: "Getting Started with `HydeNet`"
author: "Jarrod Dalton and Benjamin Nutter"
date: "11 Jun 2015"
output:
  html_document:
    fig_caption: yes
    number_section: yes
    toc: yes
  pdf_document:
    fig_caption: yes
    number_section: yes
    toc: no
---

`HydeNet` is a package intended to facilitate modeling of hybrid Bayesian networks and influence diagrams (a.k.a. decision networks). A Bayesian network, formally defined, is a joint probability distribution for a set of random variables for which the set of conditional independencies can be represented using a directed acyclic graph. Each node represents a random variable, and each link represents the direction of influence between two nodes. The probability distribution for any given node is defined as conditional (only) on its parent nodes, and every node is conditionally independent from all of its non-descendants given data on its parent nodes.

Bayesian networks are powerful *dynamic inference* models that allow for updating predictions of unobserved nodes in the network as evidence is collected. They can be constructed using expert knowledge, or by using *structure learning* algorithms. `HydeNet` assumes the first approach: all networks are manually constructed through collaboration with subject matter experts. Users interested in structure learning problems --- which are popular in -omics applications, for example --- are encouraged to try the [`bnlearn` package](http://www.jstatsoft.org/v35/i03) by Marco Scutari.

Influence diagrams (or decision networks) are extended Bayesian networks which incorporate two additional types of nodes: decision nodes and utility nodes. Decision nodes are assumed to be manipulable by the actor, while utility nodes are deterministic functions of one or more parent nodes which produce numeric outputs. When there are multiple decision nodes in the network, specific combinations of decision node values are referred to as *policies*. We can use these networks to study the distribution of utility as it relates to various decision-making policies, and to conduct value-of-information analyses.

Packages exist for **exact** inference on standard Bayesian networks (with no decision or utility nodes) when the networks fit any of the following criteria:

* All nodes are discrete/categorical in nature
* All nodes are Gaussian in nature
* All nodes are either Gaussian or discrete/categorical in nature (i.e., conditional linear gaussian models)

**[packages]**

Importantly, exact inference on Bayesian networks is an *NP*-hard problem. When networks become large, either in the number of parameters in the number of nodes, exact inference algorithms such as junction tree are computationally expensive. In these situations, **approximate** inference may be an appealing alternative. Several methods for approximate inference on Bayesian networks exist. Most popular are Markov Chain Monte Carlo sampling and the EM algorithm. `HydeNet` implements Markov Chain Monte Carlo inference through an interface to [JAGS](http://mcmc-jags.sourceforge.net/). Fundamentally, HydeNet works by writing a JAGS script according to the structure and parameterization of your graphical model, and calling JAGS with that script. 

## `HydeNet` Installation

If you don't already have JAGS installed, you will receive an error when `HydeNet` tries to load the `rjags` package.  `rjags` searches your system for an installation of JAGS and throws an error if none is found.  You will need to [download and install JAGS](http://sourceforge.net/projects/mcmc-jags/files/) before using `HydeNet`.

Installing `HydeNet` from CRAN is straightforward and can be done with the usual syntax:
```{r, eval=FALSE}
install.packages("HydeNet")
```

If you wish to install a more recent or development version from GitHub, you may need to point R to the BioConductor repositories.  

```{r, eval=FALSE}
setRepositories(ind=1:2)
devtools::install_github("nutterb/HydeNet")
```

## A Simple Bayesian Network Analysis

First we load the library: 

```{r}
library(HydeNet)
```


## Global `HydeNet` Options
There are a couple of global options `HydeNet` establishes that you should be aware of.  

### `Hyde_fitModel`
The `Hyde_fitModel` controls the behavior of `setNode` function.  If `FALSE`, the model described by the arguments will not be fit until the JAGS model statement is written by `writeNetworkModel`.  

The option can be set by using the code below.  The default setting is `FALSE`.

```{r, eval=FALSE}
options(Hyde_fitModel=FALSE)
```

Realistically, the time spent to fit the model will be spent one way or another, and it's a matter of preference for where you spend that time.  If you wish to do it
all at once when calling `writeNetworkModel`, set the option to `FALSE`.  Your printed output when reviewing a network will appear as follows:

```{r, echo=FALSE}
data(PE, package='HydeNet')
autoNet <- HydeNetwork(~ wells
                       + pe | wells
                       + d.dimer | pregnant*pe
                       + angio | pe
                       + treat | d.dimer*angio
                       + death | pe*treat,
                       data = PE)
autoNet <- setNode(autoNet, treat,
                   nodeFormula = treat ~ poly(d.dimer, 2) + angio,
                   p = fromData())
```
```{r, echo=FALSE}
print(autoNet, treat)
```

Notice that the `mu` and `tau` parameters are not explicitly defined, but only give a notice that they will be estimated from the data.

If the `Hyde_fitModel` option is set to `TRUE`, the output would appear as follows:
```{r, echo=FALSE}
library(HydeNet)
options(Hyde_fitModel=TRUE)
data(PE, package='HydeNet')
autoNet <- HydeNetwork(~ wells
                       + pe | wells
                       + d.dimer | pregnant*pe
                       + angio | pe
                       + treat | d.dimer*angio
                       + death | pe*treat,
                       data = PE)
autoNet <- setNode(autoNet, treat,
                   nodeFormula = treat ~ poly(d.dimer, 2) + angio,
                   p = fromData())
print(autoNet, treat)
```


### `Hyde_maxDigits`
This options, set to 5 by default, controls the number of decimal places printed in the JAGS model code.  It can be increased or decreased depending on the level of precision you need or want in your estimates.

```{r}
library(HydeNet)
data(PE, package='HydeNet')
autoNet <- HydeNetwork(~ wells
                       + pe | wells
                       + d.dimer | pregnant*pe
                       + angio | pe
                       + treat | d.dimer*angio
                       + death | pe*treat,
                       data = PE)
writeNetworkModel(autoNet, pretty=TRUE)
```

If 5 digits is too much for your taste:

```{r}
library(HydeNet)
options(Hyde_maxDigits=2)
data(PE, package='HydeNet')
autoNet <- HydeNetwork(~ wells
                       + pe | wells
                       + d.dimer | pregnant*pe
                       + angio | pe
                       + treat | d.dimer*angio
                       + death | pe*treat,
                       data = PE)
writeNetworkModel(autoNet, pretty=TRUE)
```

## A Note About Printing
**This note applies to R versions less than 3.2.**

You may notice throughout the vignettes that we tend to call the print function explicitly.  That is, we use `print(object)` instead of simply submitting `object` to the console.  The `HydeNet` objects can get pretty large, and the implicit printing can become pretty slow as a result.  Consider the following comparison:

```{r, eval=FALSE}
> #* Object based on a list of models
> g1 <- lm(wells ~ 1, data=PE)
> g2 <- glm(pe ~ wells, data=PE, family="binomial")
> g3 <- lm(d.dimer ~ pe + pregnant, data=PE)
> g4 <- xtabs(~ pregnant, data=PE)
> g5 <- glm(angio ~ pe, data=PE, family="binomial")
> g6 <- glm(treat ~ d.dimer + angio, data=PE, family="binomial")
> g7 <- glm(death ~ pe + treat, data=PE, family="binomial")

> bagOfModels <- list(g1,g2,g3,g4,g5,g6,g7)
> bagNet <- HydeNetwork(bagOfModels)

> #* Time to print bagNet implicitly
> a <- Sys.time()
> bagNet
> b <- Sys.time()
> b-a
Time difference of 33.53736 secs

> #* Time to print bagNet explicitly
> a <- Sys.time()
> print(bagNet)
> b <- Sys.time()
> b-a
Time difference of 0 secs
```


