<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{Decision Networks}
-->
---
title: "Decision Network (Influence Diagram) Analyses in HydeNet"
author: "Jarrod Dalton and Benjamin Nutter"
date: "24 Apr 2015"
output:
  html_document:
    fig_caption: yes
    number_section: yes
    toc: yes
  pdf_document:
    fig_caption: yes
    number_section: yes
    toc: no
---


Decision networks are Bayesian networks where a subset of nodes represents *decisions* that may be chosen by an actor (or actors) and another subset of nodes represents *utilities* associated with certain outcomes. These networks are commonly referred to in the literature as *influence diagrams*.

## Example Decison Network: Blackjack

In the ensuing discussion, we will use the casino game blackjack as our primary example of an influence diagram model. In blackjack, two cards are dealt to both the player and the dealer. Points are assigned to each card as follows:

|Card                     |Points         |
|:------------------------|:--------------|
|2 through 9              |Face Value     |
|Ten, Jack, Queen or King |10 Points      |
|Ace                      |1 or 11 points (player choice)|

For the dealer, one card (called the *upcard*) is dealt face up and the other is dealt face down. Thus, the player has only information on the upcard to guide decision-making. In the most basic form of the game (i.e., ignoring double-down, insurance and split decisions), the player is faced with the decision to *hit* or *stand*.  If the player chooses to hit, they are dealt another card and the points on that card are added to the player's previous total points.  If the total points adds to an amount greater than 21, the player *busts* (i.e., loses their money). Otherwise, the player is given another decision to hit or stand. This process continues until the player is either happy with their point total or they bust.  Once the player is all done taking cards (again, assuming they haven't busted), the dealer deals itself cards until its total is greater than or equal to 17 or it has busted. 

We have included some blackjack hand data in the package (data frame object `bjdata`) to demonstrate the process of populating these decision nodes. These data are completely fake, so results of our analysis should not be operationalized at the casino; besides, even the optimal "basic strategy" of deciding when and when not to take another card results in a net expected loss. Below is a sample (omitting card 5 data since it infrequently gets dealt):

|card1 |card2 | initialPoints| hit1|card3 | pointsAfterCard3| hit2|card4 | pointsAfterCard4| hit3|
|:-----|:-----|-------------:|----:|:-----|----------------:|----:|:-----|----------------:|----:|
|A     |2     |            13|    1|A     |               14|    1|6     |               20|    0|
|4     |A     |            15|    0|      |                 |     |      |                 |     |
|9     |A     |            20|    0|      |                 |     |      |                 |     |
|4     |2     |             6|    1|5     |               11|    0|      |                 |     |
|4     |A     |            15|    1|10-K  |               15|    1|9     |               24|     |
|3     |2     |             5|    1|9     |               14|    0|      |                 |     |
|10-K  |2     |            12|    1|A     |               13|    1|4     |               17|    0|
|8     |3     |            11|    0|      |                 |     |      |                 |     |
|9     |10-K  |            19|    0|      |                 |     |      |                 |     |
|A     |10-K  |            21|    0|      |                 |     |      |                 |     |
|6     |9     |            15|    0|      |                 |     |      |                 |     |
|2     |3     |             5|    1|4     |                9|    1|4     |               13|    0|
|7     |4     |            11|    1|A     |               12|    1|10-K  |               22|     |
|10-K  |10-K  |            20|    0|      |                 |     |      |                 |     |
|4     |10-K  |            14|    0|      |                 |     |      |                 |     |


To begin the modeling, we first construct a skeleton `HydeNet` model object, (i.e., a graphical model for which node characteristics have not yet been populated. See our vignette titled "Working with HydeNetwork Objects" for a general overview of network construction.

```{r, echo=FALSE, message=FALSE}
library(HydeNet)
```
```{r, fig.width=7, fig.height=10}
net <- HydeNetwork(~ card1.ace | card1
                   + card2.ace | card2
                   + initialPoints | card1*card2*card1.ace*card2.ace
                   + hit1 | initialPoints*dealerUpcard
                   + card3 | hit1
                   + card3.ace | card3
                   + pointsAfterCard3 | initialPoints*card3*card3.ace
                   + hit2 | pointsAfterCard3*dealerUpcard
                   + card4 | hit2
                   + card4.ace | card4
                   + pointsAfterCard4 | pointsAfterCard3*card4*card4.ace
                   + hit3 | pointsAfterCard4*dealerUpcard
                   + card5 | hit3
                   + card5.ace | card5
                   + pointsAfterCard5 | pointsAfterCard4*card5*card5.ace
                   + playerFinalPoints | initialPoints*hit1*pointsAfterCard3
                                         *hit2*pointsAfterCard4*hit3*pointsAfterCard5
                   + dealerFinalPoints | dealerUpcard
                   + payoff | playerFinalPoints*dealerFinalPoints)
```

We momentarily defer visualization of the network structure until after we've specified the types (random variable, deterministic, decision, or utility) of all the nodes in the network, since `plot.HydeNetwork()` allows for enhanced visualization of decision networks. See our vignette titled "Building and Customizing HydeNet Plots" for details.

First, we will designate the decision and utility nodes using `setDecisionNodes()` and `setUtilityNodes()`. These functions merely set flags within the `HydeNetwork` object, to be used in later computations:

```{r}
net <- setDecisionNodes(net, hit1, hit2, hit3)
net <- setUtilityNodes(net, payoff)

net$nodeDecision$hit2
net$nodeUtility$payoff
```


## Decision Nodes

Decision nodes, while special, can also be thought of as random variables and fed into JAGS just as typical, non-manipulable random variables are fed into JAGS. When decision nodes have parents, the implication is that the parent nodes provide *information* that is used to guide the process of decision-making for that node. Hence, these links are called *information links*. We can think of the conditional probability distribution for a decision node as a frequency (or, alternatively, a representation of belief) of observed decisions under distinct combinations of parent nodes within a population. For example, we may have data on observed hit/stand decisions in blackjack, from which a logistic regression model can estimate the relationship between current point total and probability of taking another card. (Actually, this model ignores relevant information on how many aces the player holds: Aces decrease the likelihood of a bust on the next card and thus increase the chances of a hit decision; however, we do not concern ourselves with this for the sake of simplicity.) Note that the data are independent of how many cards the player holds - all that matters for a given hit/stand decision is the current point total. 

Therefore, the conditional distribution of each of the three decision nodes can be specified using a single `glm` model object. 


We can manipulate this data frame to get a single two-column data frame for use in our GLM for hit decisions:

```{r}
data(bjdata)

attach(bjdata)
glmdata <- data.frame(points = c(initialPoints, pointsAfterCard3, pointsAfterCard4),
                      hit    = c(hit1,hit2,hit3))
detach(bjdata)
glmdata <- glmdata[!is.na(glmdata$hit),]

g <- glm(hit ~ points, data=glmdata, family="binomial")
summary(g)$coef

```

## Utility Nodes

Several of the other nodes are deterministic in nature (e.g., `cardX.ace` is an indicator variable present in the network for ease of computing the player's point totals after each card is dealt, which are also deterministic nodes). These are populated using the following code:

```
net <- setNode(net, card1.ace, "determ", define=fromFormula(), nodeFormula=card1.ace ~ ifelse(card1==1,1,0))
net <- setNode(net, card2.ace, "determ", define=fromFormula(), nodeFormula=card2.ace ~ ifelse(card2==1,1,0))
net <- setNode(net, card3.ace, "determ", define=fromFormula(), nodeFormula=card3.ace ~ ifelse(card3==1,1,0))
net <- setNode(net, card4.ace, "determ", define=fromFormula(), nodeFormula=card4.ace ~ ifelse(card4==1,1,0))
net <- setNode(net, card5.ace, "determ", define=fromFormula(), nodeFormula=card5.ace ~ ifelse(card5==1,1,0))
net <- setNode(net, initialPoints, "determ", define=fromFormula(), nodeFormula=initialPoints~card1+card2)
net <- setNode(net, pointsAfterCard3, "determ", define=fromFormula(),
               nodeFormula=pointsAfterCard3 ~ initialPoints+card3)
net <- setNode(net, pointsAfterCard4, "determ", define=fromFormula(),
               nodeFormula=pointsAfterCard4 ~ pointsAfterCard3+card4)
net <- setNode(net, pointsAfterCard5, "determ", define=fromFormula(),
               nodeFormula=pointsAfterCard5 ~ pointsAfterCard4+card5)
net <- setNode(net, playerFinalPoints, "determ", define=fromFormula(),
               nodeFormula=playerFinalPoints ~ playerFinalPoints+3)

```



## Visualization of Decision Networks

With the `HydeNet` model now fully specified, we can now visualize the decision network. The `plot` method for `HydeNetwork` objects supports the use of different node shapes and colors corresponding to each node type (e.g., random variable node, decision node, utility node, or deterministic node).





The conditional probability table of the `dealerFinalPoints` node given its parent node `dealerUpcard` (assuming the dealer is drawing from a deck of infinite size) is summarized in the below table (*source: https://www.blackjackinfo.com/dealer-outcome-probabilities. Accessed 2015-04-24.*):


|**`dealerUpcard`**|*Pr(Blackjack)*|*Pr(Bust)*|*Pr(17)*|*Pr(18)*|*Pr(19)*|*Pr(20)*|*Pr(21)*|
|:---|:---|:---|---:|---:|---:|---:|---:|
|2|0.0000|0.3567|0.1301|0.1365|0.1313|0.1257|0.1196|
|3|0.0000|0.3767|0.1263|0.1320|0.1271|0.1218|0.1162|
|4|0.0000|0.3971|0.1224|0.1273|0.1228|0.1179|0.1126|
|5|0.0000|0.4177|0.1184|0.1229|0.1184|0.1138|0.1089|
|6|0.0000|0.4395|0.1148|0.1148|0.1148|0.1103|0.1057|
|7|0.0000|0.2623|0.3686|0.1378|0.0786|0.0786|0.0741|
|8|0.0000|0.2447|0.1286|0.3593|0.1286|0.0694|0.0694|
|9|0.0000|0.2284|0.1200|0.1200|0.3508|0.1200|0.0608|
|10-King|0.0714|0.2134|0.1121|0.1121|0.1121|0.3442|0.0347|
|Ace|0.2353|0.1535|0.0635|0.1582|0.1582|0.1582|0.0732|



```{r, fig.width=7, fig.height=10}
net <- HydeNetwork(~ card1.ace | card1
                   + card2.ace | card2
                   + initialPoints | card1*card2*card1.ace*card2.ace
                   + hit1 | initialPoints*dealerUpcard
                   + card3 | hit1
                   + card3.ace | card3
                   + pointsAfterCard3 | initialPoints*card3*card3.ace
                   + hit2 | pointsAfterCard3*dealerUpcard
                   + card4 | hit2
                   + card4.ace | card4
                   + pointsAfterCard4 | pointsAfterCard3*card4*card4.ace
                   + hit3 | pointsAfterCard4*dealerUpcard
                   + card5 | hit3
                   + card5.ace | card5
                   + pointsAfterCard5 | pointsAfterCard4*card5*card5.ace
                   + playerFinalPoints | initialPoints*hit1*pointsAfterCard3
                                         *hit2*pointsAfterCard4*hit3*pointsAfterCard5
                   + dealerFinalPoints | dealerUpcard
                   + payoff | playerFinalPoints*dealerFinalPoints)



net <- setDecisionNodes(net, hit1, hit2, hit3)
net <- setUtilityNodes(net, payoff)

decisionNodes <- names(which(unlist(net$nodeDecision)))
utilityNodes <- "payoff"  #names(which(unlist(net$nodeDecision)))
determNodes <- names(which(unlist(net$nodeType)=="determ"))

shapes <- rep("box",length(decisionNodes)+length(utilityNodes));
names(shapes) <- c(decisionNodes, utilityNodes)

fills <- c(rep("cyan",length(decisionNodes)), rep("yellow",length(utilityNodes)))
names(fills) <- c(decisionNodes, utilityNodes)

fontcols <- rep("gray70", length(determNodes))
names(fontcols) <- c(determNodes)

cols <- rep("gray70",length(determNodes));
names(cols) <- determNodes

nodeAttribs <- list(shape=shapes, fillcolor=fills, fontcolor=fontcols, color=cols)

attribs <- list(node=list(shape="ellipse", fixedsize=FALSE, fillcolor="white", style="solid"))
#graphics.off()
plot(net, attrs=attribs)
#plot(net, attrs=list(node=list(fixedsize=FALSE)))

```



## A Brief Note of Caution

decision networks are tricky business. 3 types of asymmetry in decision networks. Currently, our package only allows for fully symmetric decision networks or networks that exhibit order asymmetry. However, careful use of the package to evaluate other situations is possible. We give some general guidance below on how to think about decision processes:

Decision/data process:  (A1, D1, A2, D2, ..., A_n-1, D_n-1, An)










