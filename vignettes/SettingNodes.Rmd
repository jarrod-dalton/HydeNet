<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{Specifying Node Distributions}
-->
---
title: "Specifying Node Distributions in HydeNet"
author: "Jarrod Dalton and Benjamin Nutter"
date: "3 Feb 2015"
output:
  html_document:
    fig_caption: yes
    number_section: yes
    toc: yes
  pdf_document:
    fig_caption: yes
    number_section: yes
    toc: no
---

Setting up Bayesian network models with **HydeNet** generally involves two components -- the network structure and the (conditional) probability distribution of each node (given any parent nodes). Network structure is specified within the `HydeNetwork()` function, while node distributions are set using either `HydeNetwork()` or `setNode()`.

The default behavior of `HydeNetwork()` when used with a training dataset (parameter `data`) is to run linear regression, logistic regression, or multinomial logistic regression, depending on the classes (and number of levels, for factors) of the variables in the data frame and the user-specified network structure. For this, we use the functions `lm()`, `glm(..., family="binomial")`, and `nnet::multinom()` respectively.

When `HydeNetwork()` is used without training data, the distributions for each node in the network are manually specified. This is accomplished with the `setNode()` function. As we discuss below, we have implemented a wide array of techniques for specifying node distributions with `setNode()`.

We start by loading the package:
```{r, eval=2}
install.packages("HydeNet")
library(HydeNet)
```
The network we will study involves the diagnosis and treatment of pulmonary embolism, or PE (node **pe**).  PE is a condition where the arteries carrying blood to the lungs get blocked, typically by a blood clot that dislodged from a vein in the leg. There are two commonly-used tests for diagnosing PE. One is a blood test called D-dimer (node **d.dimer**), and the other is pulmonary angiography (node **angio**). For each, the probability of positive and negative test values depends on the status of PE. In other words, the conditional distribution function for each test node can be defined using the sensitivity and specificity of each test. The D-dimer test also is affected by pregnancy (node **pregnant**), with higher false positive rates.  Clinicians prior beliefs about the likelihood of PE are captured in a score (node **wells**). Since PE cannot directly be observed, the likelihood of a patient receiving treatment (node **treat**) depends on the test results. And the likelihood of survival through hospital discharge (node **death**) depends on both the status of the disease and whether or not the patient received treatment.  

A graphical representation of the PE network can be constructed based on an unpopulated **HydeNetwork** object (i.e., a "base" object for which node distributions have not yet been specified):

```{r}
net <- HydeNetwork(~ wells
                   + pe | wells
                   + d.dimer | pregnant*pe
                   + angio | pe
                   + treat | d.dimer*angio
                   + death | pe*treat)

attribs <- list(node = list(shape="ellipse", fillcolor="#FDAE6B"))

plot(net, attrs=attribs)
```


Note that the `attribs` object and use of the `attrs` parameter in the `plot()` call use the Rgraphviz package. See `vignette(topic="Rgraphviz", package = "Rgraphviz")` for details.

The **HydeNetwork** object we created, called `net`, is worth exploring:

```{r, echo=FALSE}
net
```

Since we haven't given `HydeNetwork()` a training dataset from which to extract node types (again, in which case nodes are assumed to be either binary, categorical, or normal depending on the class of the variables in the dataset), we have a skeleton object where each node is distributed as normal given its parent nodes.  The parameters `mu` and `tau` are to this point unspecified (note: in JAGS, the mean and *precision* are specified for the normal distribution - the precision parameter $\tau$ is equal to $1/\sigma^2$).

###Using a training dataset

Using `HydeNetwork()` with a training dataset implements the following default node-specific model classes, depending on the class of the node (in other words, the class of the variable in the training dataset) and whether or not the node has parents:

|Parents? |Node Class                        |Model Type                     |Function                     |
|:--------|:---------------------------------|:------------------------------|:----------------------------|
|No       |`factor` with any number of levels|Tabulation                     |`xtabs()`                    |
|Yes      |`factor` with 2 levels            |Logistic Regression            |`glm(..., family="binomial")`|
|Yes      |`factor` with 3+ levels           |Multinomial Logistic Regression|`nnet::multinom()`           |
|Yes or No|`numeric` or `integer`            |Ordinary Least Squares         |`lm()`                       |

The syntax for building a Bayesian network using training data is rather simple:

```{r}
data(PE, package='HydeNet')
autoNet <- HydeNetwork(~ wells
                       + pe | wells
                       + d.dimer | pregnant*pe
                       + angio | pe
                       + treat | d.dimer*angio
                       + death | pe*treat,
                       data = PE)
writeNetworkModel(autoNet, pretty=TRUE)
```
We can see by the output that the models have all been populated, and verify that these are indeed the coefficients we obtain from the functions in the above table:

```{r}
glm(treat ~ d.dimer+angio, data=PE, family="binomial")$coef
```
```{r}
xtabs(~PE$pregnant) / nrow(PE)
```

###Specifying Univariate Distributions for Root Nodes

#### Binary Root Nodes

The most straightforward way to specify distributions for root nodes, or nodes without parents is by using `setNode` with specific distributions and parameters.  For example, returning to our original unpopulated network (object `net`), we can define a Bernoulli distribution for node **pregnant**:

```{r}
net <- setNode(network = net, node = pregnant,
               nodeType = "dbern", p=.4)
net
```

In the code above, we can see that `setNode` works by returning a modified *HydeNet* object. In the output, node **pregnant** is now Bernoulli with probability of 0.4.

#### Normally-distributed Root Nodes

Univariate normal distributions are specified using `nodeType = "dnorm"`. We will specify a normal distribution with a $\mu = 5$ and $\sigma = 1.5$ for node **wells**:

```{r}
net <- setNode(net, wells,
               nodeType = "dnorm", 
               mu = 5, tau = 1 / (1.5^2))

net$nodeType$wells
net$nodeParams$wells
```

#### Multicategory Root Nodes

Suppose instead that the Wells score was categorical in nature, with three values (e.g., low, medium and high).  We can specify categorical distributions as follows:


```{r}
net <- setNode(net, wells,
               nodeType = "dcat",
               pi = vectorProbs(p = c(.3, .6, .1), wells) )
               
net$nodeType$wells
net$nodeParams$wells
```

Note here that we have overwritten the node distribution within the object `net` to be categorical in nature.

The `vectorProbs()` function converts a probability vector into JAGS code, as seen above in the list element `net$nodeParams$wells`. This function will by default normalize probability vectors, so that counts can be directly fed into the model:

```{r}
net <- setNode(net, wells,
               nodeType = "dcat",
               pi = vectorProbs(p = c(37, 162, 48), wells) )
               
net$nodeType$wells
net$nodeParams$wells
```

We could have achieved the same by directly inserting the JAGS code into the pi parameter:

```{r}
net <- setNode(net, wells,
               nodeType = "dcat",
               pi = "pi.wells[1] <- 0.15; pi.wells[2] <- 0.66; pi.wells[3] <- 0.19")
```

#### Other Univariate Distributions

**Hyde** supports all the statistical distributions supported by JAGS.  A table of these distributions is stored in the `jagsDists` dataset. We show a portion of this table below:

```{r, eval=FALSE}
data(jagsDists, package='HydeNet')
jagsDists[1:15,c(1,2,5,6)]
```

|DistName                  |FnName     |Parameters |paramLimit         |
|:-------------------------|:----------|:----------|:------------------|
|Beta                      |dbeta      |a          |> 0                |
|Beta                      |dbeta      |b          |> 0                |
|Chi-square                |dchisqr    |k          |> 0                |
|Double exponential        |ddexp      |mu         |                   |
|Double exponential        |ddexp      |tau        |> 0                |
|Exponential               |dexp       |lambda     |> 0                |
|F                         |df         |n          |> 0                |
|F                         |df         |mu         |> 0                |
|Gamma                     |dgamma     |r          |> 0                |
|Gamma                     |dgamma     |lambda     |> 0                |
|Generalized gamma         |dgen.gamma |r          |> 0                |
|Generalized gamma         |dgen.gamma |b          |> 0                |
|Generalized gamma         |dgen.gamma |lambda     |> 0                |
|Logistic                  |dlogis     |mu         |                   |
|Logistic                  |dlogis     |tau        |> 0                |

So, to assign a Weibull distribution to a node *XYZ*, we would use  the following code:
```{r, eval=FALSE}
net <- setNode(net, XYZ, nodeType = "dweib", nu=2, lambda=5)
```


Finally, note that there is built-in error handling when parameters are outside allowable limits:

```{r, error=TRUE}
net <- setNode(net, d.dimer, nodeType = "dpois", lambda=-10)
```





###Using Regression Equations

####Ordinary Least Squares (OLS)

For OLS models, `nodeType="dnorm"` can be used. We use a regression equation to characterize the dependency of the node on its parents. We note again that normal distributions are specified using the mean and *precision* parameters, where the precision parameter is the inverse of the variance.

`setNode()` supports the use of formula syntax to define a regression equation for a given node. This is achieved using the `fromFormula()` function with the *nodeFormula* parameter, as follows:

```{r}
net <- setNode(net, d.dimer, nodeType="dnorm",
               mu=fromFormula(), tau=1/30,  #sigma^2 = 30
               nodeFormula = d.dimer ~ 210 + 29*pregnant + 68*pe)

net$nodeType$d.dimer
net$nodeParams$d.dimer
net$nodeFormula$d.dimer
```

#WHAT IS THE RIGHT WAY TO DESCRIBE THE IMPLICIT CONVERSION OF FACTORS PREGNANT AND PE BY JAGS IN THE ABOVE MODEL?

Or, alternatively, one may directly specify JAGS code for the `mu` parameter as a character string:

```{r, eval=FALSE}
net <- setNode(net, d.dimer, nodeType="dnorm",
               mu="210 + 29*pregnant + 68*pe", tau=1/30)
```

However, the model syntax is flexible, allowing for alternative distributions to be used if desired.  For example, maybe the distribution of the residuals has heavy tails; here, the (non-standardized) Student's *t* distribution could be used:

```{r, eval=FALSE}
net <- setNode(net, d.dimer, nodeType="dt",
               mu="210 + 29*pregnant + 68*pe", tau=1/20, k=2)
```


The decision of whether to give an `R`-style formula or JAGS code is a matter of preference.  But when using `R` code, be careful that any functions used in the formula can be translated to JAGS.  A list of functions that can be translated between `R` and JAGS can be viewed by calling 

```{r, eval=FALSE}
data(jagsFunctions, package='HydeNet')
jagsFunctions
```

|jags_function |r_function |r_package |
|:-------------|:----------|:---------|
|abs           |abs        |base      |
|arccos        |acos       |base      |
|arccosh       |acosh      |base      |
|arcsin        |asin       |base      |
|arcsinh       |asinh      |base      |
|arctan        |atan       |base      |
|arctanh       |atanh      |base      |
|cos           |cos        |base      |
|cosh          |cosh       |base      |
|cloglog       |cloglog    |VGAM      |
|equals        |==         |base      |
|exp           |exp        |base      |
|icloglog      |           |          |
|ifelse        |ifelse     |base      |
|ilogit        |logit      |VGAM      |
|log           |log        |base      |
|logfact       |           |          |
|loggam        |           |          |
|logit         |logit      |VGAM      |
|phi           |pnorm      |base      |
|pow           |^          |base      |
|probit        |probit     |VGAM      |
|round         |ceiling    |base      |
|sin           |sin        |base      |
|sinh          |sinh       |base      |
|sqrt          |sqrt       |base      |
|step          |>= 0       |base      |
|tan           |tan        |base      |
|tanh          |tanh       |base      |
|trunc         |floor      |base      |


#### Logistic regression nodes 

If the intercept and slope coefficients of a logistic regression model are known, one may define a Bernoulli-distributed node using the `ilogit` function in JAGS (inverse logit):

```{r}
equation <- "-6.3 + 0.02*d.dimer + 2.9*angio - 0.005*d.dimer*angio"
net <- setNode(net, treat, nodeType="dbern",
               p=paste("ilogit(", equation, ")"), 
               validate=FALSE)
```



### Using **`R`** Model Objects

R model objects of class `lm`, `glm`, and `multinom` can be fed directly into both HydeNetwork() and setNode().










<!--
### Poisson Regression nodes
### Gamma regression nodes

## Categorical Nodes -- list (?) of multinomial logistic regression equations -- this will be tricky

## Continuous Nodes
### Regression equation with Gaussian errors

## Manual Specification using JAGS code
### Linear regression equation with cauchy errors
### Mixture distributions (do this last!)
#### Zero-inflated Poisson
#### Zero inflated negative binomial




# Node With or Without Parents -- Reading formula from existing model objects

## Reading from `lm` objects
## Reading from `glm` objects - can we make this work for lognormal
## Reading from multinom objects
## Reading from survreg objects (note the list component modelObject$dist that stores the type of distribution used for the parametric survival regression model)



# Learning Node Distributions from Training Data

## Default behavior of `HydeNetwork(.formula, data=trainingData)`
## Tutorial involving user-specified distributions for particular nodes and estimation of regression equations from data 
one node may be survival (with censoring), one may be binary, one may be normal, one may be Poisson, and the other may be categorical
-->



```{r, echo=FALSE}
#----------------------------------------------------------------------------------------------------------
# 1) Root Nodes
#----------------------------------------------------------------------------------------------------------
#  1.1) Binary
#    1.1.1) setNode(HydeNetwork, x, nodeType="dbern", p=0.62)   (need logic?  0<=p<=1)
#    1.1.2) Using JAGS code (nodeType="dbern", params="pi=0.28;"..or whatever the correct syntax is)
#  1.2) Categorical
#    1.2.1) setNode(HydeNetwork, x, nodeType="dcat",  p=c(0.62,0.08))
#           (need logic? if(length(p)==(K-1)) 0<=sum(p)<=1 else if(length(p)==K) sum(p)==1...)
#    1.2.2) Using JAGS code into the params argument, i.e., nodeType="dcat", 
#           params="pi.wells[1] = .85; pi.wells[2] = .12; pi.wells[3] = .03"
#           need specifics as to how that string needs to be constructed - for instance, 
#           do you need to use the name "pi.wells"?
#  1.3) Normal
#    1.3.1) setNode(HydeNetwork, x, nodeType="dnorm", mu=5, sigma=1.4)
#    1.3.2) Using JAGS code
#  1.4 Uniform
#    1.4.1) setNode(HydeNetwork, x, nodeType="dunif", a=0, b=10)
#    1.4.2) Using JAGS code
#  1.5 Weibull
#    1.5.1) setNode(HydeNetwork, x, nodeType="dweib", nu=3, lambda=1.5)
#    1.5.2) Using JAGS code
#  1.6 -- 1.1x  [dgamma, dexp, dpois, dnegbin, etc...]

#----------------------------------------------------------------------------------------------------------
# 2) Nodes With or Without Parents -- Manually specifying regression equations
#    >>> Do we need error checking to ensure alignment between stated terms in regression equations and 
#        network structure (i.e., if X1 and X2 are in the regression equation, they need to be stored
#        as parents of Y in the HydeNetwork object)?
#----------------------------------------------------------------------------------------------------------
#  2.1) Nodes in the exponential family -- need regression equation + link function
#    2.1.1) Ordinary Least Squares
#    2.1.2) Lognormal 
#    2.1.3) Logistic Regression nodes ... I think JAGS has a logit() function that may be useful
#    2.1.4) Poisson Regression nodes 
#    2.1.5) Gamma regression
#  2.2) Categorical nodes -- list (?) of multinomial logistic regression equations -- this will be tricky.
#  2.3) Continuous nodes
#    2.3.1) Regression equation with Gaussian errors
#  2.4) Manual specification using JAGS code
#    2.4.1) Linear regression equation with cauchy errors
#    2.4.2) Mixture distributions (do this last!)
#      2.4.2.1) Zero-inflated poisson
#      2.4.2.2) Zero-inflated negative binomial

#----------------------------------------------------------------------------------------------------------
# 3) Nodes With or Without Parents -- Reading formula from existing model objects
#    >>> Do we need error checking to ensure alignment between stated terms in regression equations and 
#        network structure (i.e., if X1 and X2 are in the regression equation, they need to be stored
#        as parents of Y in the HydeNetwork object)?
#----------------------------------------------------------------------------------------------------------
#  3.1) Reading from lm objects
#  3.2) Reading from glm objects  - can we make this work for lognormal?
#  3.3) Reading from multinom objects
#  3.4) Reading from survreg objects (note the list component modelObject$dist that stores the type
#       of distribution used for the parametric survival regression model)


#----------------------------------------------------------------------------------------------------------
# 4) Learning Node Distributions from Training Data
#----------------------------------------------------------------------------------------------------------
#  4.1) Default behavior of HydeNetwork(.formula, data=trainingData)
#  4.2) Tutorial involving user-specified distributions for particular nodes and estimation of regression
#       equations from data -- one node may be survival (with censoring), one may be binary, one may be normal,
#       one may be Poisson, and the other may be categorical
```
